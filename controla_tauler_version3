package hidato;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.lang.Math;
import java.util.Random;
import java.util.Scanner;



public class controladorTauler {
	
    private static int[][] tauler;
    private static int[][] tauler_def;
    private static int[] numDonats, posInicial;

    
    private static int tablero[][]; /* tablero sobre el que buscaremos la solucion */
    private static int solucion[][]; /* tablero donde guardaremos la solucion */
    private static int nSols; /* numero de soluciones encontradas (como mucho dos) */
    private static int nRest; /* numero de casillas que me quedan por poner */
    private static boolean usado[]; /* usado[i] nos dice si el numero i + 1 esta colocado */
    private static int n; /* anchura del tablero */
    private static int m; /* altura del tablero */
    private static int maxCas; /* numero de la casilla mas grande */
    
    
    public static void main(String[] args) {

        Scanner in = new Scanner(System.in);

        int ordre = -1;

        while (ordre != 3) {
            System.out.println("Dona'm ordres:0 =>Predefinit 1 => Genera, 2 => Soluciona, 3 => Surt");
            ordre = in.nextInt();

            switch (ordre) {
                case 0: 
                
                case 1:
                    System.out.println("Indica la dimensió del tauler");
                    int costat = in.nextInt();

                    System.out.println("Indica la cuantitat de numero incials de l'hidato, minim 2");
                    int numInicials = in.nextInt();
                    
                    //System.out.println("Indica la cuantitat de forats incials de l'hidato, minim 0 max(size /2)");

                    //generaTauler(costat, numInicials);
                    generaTauler2(costat, numInicials,0);
                    escriuTaluer();
                    break;

                case 2:
                    System.out.println("Solucio");
                    soluciona(posInicial[0], posInicial[1], 1, 0);
                    escriuTaluer();
                    break;

                case 3:
                    break;
            }
        }
    }


    public static boolean soluciona(int fila, int col, int n, int seguent) {
       // System.out.println("valor n " + n);
        int dimensioTauler = tauler.length;
        
       
        if (fila<0 || col<0 || fila>dimensioTauler-1 || col>dimensioTauler-1)//si es fora del tauler surt
            return false;
        
        
        
        if (n == numDonats[numDonats.length - 1]) // si es mas grande que el utlimo sale ya lleno tablero9
            return true;
        
        
        if (tauler[fila][col] != 0 && tauler[fila][col] != n)//si ya esta agafada la posicio i no es el nou numero surt
            return false;

        if (tauler[fila][col] == 0 && numDonats[seguent] == n)//si no hi ha cap numero pero ya esta ficat a la taula
            return false;
        

        int numRetorn = tauler[fila][col];
        if (numRetorn == n) //si el del tauler es igual al que poso incremento numdonats
            seguent++;

        tauler[fila][col] = n;
        int[] direccioVertical = new int[]{-1,-1,-1,0,0,1,1,1};
        int[] direccioHoritzontal = new int[]{-1,0,1,-1,1,-1,0,1};
        for (int i = 0; i < direccioVertical.length; ++i)
            if (soluciona(fila + direccioHoritzontal[i], col + direccioVertical[i], n + 1, seguent))
                return true;

        tauler[fila][col] = numRetorn;
        return false;
    }
    
    public static void num_solucions(int fila, int col, int n, int seguent, Contador cont){
    	int dimensioTauler = tauler.length;
    	if(cont.x == 2);
	    else{
	    	if(n == numDonats[numDonats.length - 1]){
	    		++cont.x;
	    		System.out.println("eeeeeeeeeeeee paso guate  " + n);
	    	}
	    	else{
	    		System.out.println("cuantas aquiiiiii  " + n);
	    		if (fila<0 || col<0 || fila>dimensioTauler-1 || col>dimensioTauler-1);//si es fora del tauler surt
	    	            
	    		else if (tauler[fila][col] != 0 && tauler[fila][col] != n);//si ya esta agafada la posicio i no es el nou numero surt
	              
	    		else if (tauler[fila][col] == 0 && numDonats[seguent] == n);//si no hi ha cap numero pero ya esta ficat a la taula
	    		else{
	    			int numRetorn = tauler[fila][col];
	    	        if (numRetorn == n) //si el del tauler es igual al que poso incremento numdonats
	    	            seguent++;
	    			
	    			tauler[fila][col] = n;
	    	        int[] direccioVertical = new int[]{-1,-1,-1,0,0,1,1,1};
	    	        int[] direccioHoritzontal = new int[]{-1,0,1,-1,1,-1,0,1};
	    	        
		    		for (int i = 0; i < direccioVertical.length; ++i)
		    			num_solucions(fila + direccioHoritzontal[i], col + direccioVertical[i], n + 1, seguent,cont);
		                    
		
		            tauler[fila][col] = numRetorn;
		            
	    		}    		
	    		
	    	}
	    }	
    }
    
    public static void BuscarSolucion(int anchura, int altura) {
        n = anchura;
        m = altura;
        tablero = tauler.clone();
        solucion = null;
        nSols = nRest = maxCas = 0;
        usado = new boolean[altura*anchura];

        for (int i = 0; i < altura*anchura; ++i)
            usado[i] = false;

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (tablero[i][j] > 0) usado[tablero[i][j] - 1] = true;
                else if (tablero[i][j] == 0) ++nRest;
                maxCas = Math.max(maxCas, tablero[i][j]);
            }
        }

        backtrack();
    }
    
    private static void backtrack() {
        if (nRest == 0) {
            solucion = tablero.clone();
            ++nSols;
        }
        else {
            int minI = 0;
            int minJ = 0;
            int minPosats = 10;

            for (int i = 0; i < n; ++i) {
                for (int j = 0; j < m; ++j) {
                    if (tablero[i][j] == 0) {
                        int nVolt = 0;
                        int k1 = Math.max(0, i - 1);
                        int k2 = Math.min(n - 1, i + 1);
                        int s1 = Math.max(0, j - 1);
                        int s2 = Math.min(m - 1, j + 1);

                        for (int k = k1; k <= k2; ++k)
                            for (int s = s1; s <= s2; ++s)
                                if (tablero[k][s] == 0)
                                    ++nVolt;

                        if (nVolt < minPosats) {
                            minPosats = nVolt;
                            minI = i;
                            minJ = j;
                        }
                    }
                }
            }

            --nRest;
            for (int k = 1; (nSols < 2) && (k < maxCas - 1); ++k) {
                if(!usado[k]) {
                    usado[k] = true;
                    tablero[minI][minJ] = k + 1;

                    if (fastCheck(minI, minJ) && deepCheck()) backtrack();

                    tablero[minI][minJ] = 0;
                    usado[k] = false;
                }
            }
            ++nRest;
        }
    }
    
    private static boolean fastCheck(int i, int j) {

        for (int k = Math.max(0, i - 1); k <= Math.min(n - 1, i + 1); ++k) {
            for (int s = Math.max(0, j - 1); s <= Math.min(m - 1, j + 1); ++s) {
                if (tablero[k][s] > 0) {
                    boolean antFound = false;
                    boolean sigFound = false;
                    int nBuits = 0;

                    int t1 = Math.max(0, k - 1);
                    int t2 = Math.min(n - 1, k + 1);
                    int r1 = Math.max(0, s - 1);
                    int r2 = Math.min(m - 1, s + 1);

                    for (int t = t1; t <= t2; ++t) {
                        for (int r = r1; r <= r2; ++r) {
                            if (tablero[t][r] == 0) ++nBuits;
                            else if (tablero[t][r] == tablero[k][s] - 1)
                                antFound = true;
                            else if (tablero[t][r] == tablero[k][s] + 1)
                                sigFound = true;
                        }
                    }

                    if (nBuits == 1 && tablero[k][s] > 1 && tablero[k][s] < maxCas &&
                      !antFound && !sigFound) return false;
                    else if (nBuits == 0) {
                        if (tablero[k][s] == 1) {
                            if (!sigFound) return false;
                        }
                        else if (tablero[k][s] == maxCas) {
                            if (!antFound) return false;
                        }
                        else if (!sigFound || !antFound) return false;
                    }
                    if (!antFound && tablero[k][s] > 1 && usado[tablero[k][s] - 2])
                        return false;
                    if (!sigFound && tablero[k][s] < maxCas && usado[tablero[k][s]])
                        return false;
                }
            }
        }
        return true;
    }
    
    private static boolean deepCheck() {
        int dist[][] = new int[n][m];

        int ant = 0;
        for (int k = 1; k < maxCas; ++k) {
            if (usado[k]) {
                Queue<Integer> cola = new LinkedList<Integer>();
                int pos = 0;
                for (int i = 0; i < n; ++i) {
                    for (int j = 0; j < m; ++j) {
                        if (tablero[i][j] == ant + 1) {
                            pos = i*m + j;
                            dist[i][j] = 0;
                        }
                        else dist[i][j] = n + m;
                    }
                }
                cola.add(pos);
                boolean ok = true;
                while (ok && !cola.isEmpty()) {
                    int val = cola.poll().intValue();
                    int x = val/m;
                    int y = val%m;
                    int nuevaDist = 1 + dist[x][y];
       
                    for (int s = Math.max(0, x - 1); ok && s <= Math.min(n - 1, x + 1); ++s) {
                        for (int t = Math.max(0, y - 1); ok && t <= Math.min(m - 1, y + 1); ++t) {
                            if (tablero[s][t] == k + 1) {
                                if (nuevaDist > k - ant) return false;
                                ok = false;
                            }
                            else if ((tablero[s][t] == 0) && (nuevaDist < dist[s][t])) {
                                dist[s][t] = nuevaDist;
                                cola.add(s*m + t);
                            }
                        }
                    }
                }
                if (ok) return false;
                ant = k;
            }
        }
        return true;
    }

    public static void escriuTaluer() {     // S'ha de refer escriure per quan tinguem les classes cel·la i tauler
        for (int[] row : tauler) {
            for (int c : row) {
                if (c == -1)
                    System.out.print(" . ");
                else
                    System.out.printf(c > 0 ? "%2d " : "__ ", c);
            }
            System.out.println();
        }
    }

   
    
    public static void generaTauler2(int costat, int numInicials, int forats) {
    	 int numMaxim = costat*costat - forats;
    	 Coord posInicialProvisional = new Coord();
         Coord coordenadaAux = new Coord();
         List<Coord> conjuntGeneratPos = new ArrayList<>();
         List<Integer> conjuntGenerat = new ArrayList<>();
         int[][] taulerGenerat = new int[costat][costat];
         int[][] taulerGeneratAux = new int[costat][costat];
         Random rand = new Random();
         int veins[][] = new int [costat][costat];
         int num_posar = 0;

         //FER FORATS
         boolean tauler_correcte = false;
         while(!tauler_correcte){
	         //do while....
        	 taulerGeneratAux = taulerGenerat.clone();
        	 conjuntGenerat.clear();
	         init_matriu(veins, 0);
	         init_veins(veins,taulerGeneratAux); // inicialitza numero de veis de cada numero
	         int posx, posy;
		     do{
		         posx = rand.nextInt(costat);
		         posy = rand.nextInt(costat);
		         coordenadaAux.x = posx;
		         coordenadaAux.y = posy;
		     }while(taulerGeneratAux[posx][posy] != 0 && !conjuntGeneratPos.contains(coordenadaAux));
		     
	         conjuntGeneratPos.add(coordenadaAux);
	         posInicialProvisional.x = posx; //posicio del 1
	         posInicialProvisional.y = posy;
	         
	         num_posar = 1;
	         boolean pathing = true;
	         
	         while(pathing){
	        	 taulerGeneratAux[coordenadaAux.x][coordenadaAux.y] = num_posar;
	        	 conjuntGenerat.add(num_posar);
	        	 if(veins_accesibles(coordenadaAux.x,coordenadaAux.y,taulerGeneratAux) || num_posar == numMaxim) pathing = false;
	        	 else{
	        		 conjuntGeneratPos.clear();
	        		 act_veins(coordenadaAux.x,coordenadaAux.y,veins,taulerGeneratAux,conjuntGeneratPos);
	        		 int aux_Random = rand.nextInt(conjuntGeneratPos.size());
	        		 coordenadaAux = conjuntGeneratPos.get(aux_Random);
	        		 ++num_posar;
	        	 }
	        
	         }
	         if(num_posar == numMaxim) tauler_correcte = true; //Tauler correcte, pasem a treure numeros.
	         
         }//fi while
         posInicial = new int[]{posInicialProvisional.x, posInicialProvisional.y};
         //TREURE NUMEROS fins NUMINICIALS SI ES POT O FINS QUE TROBEN MES DE 1 SOLUCIO*/
         
         Collections.sort(conjuntGenerat);
         numDonats = new int[conjuntGenerat.size()];
         for (int i = 0; i < numDonats.length; i++)
             numDonats[i] = conjuntGenerat.get(i);
         tauler = taulerGeneratAux;
         
         int numMin = numMaxim;
         //treu_nums(posInicialProvisional.x,posInicialProvisional.y,numInicials,num_posar,numMaxim,numMin,1);
         Contador aux = new Contador();
         aux.x = 0;
    	 quita_nums(numInicials, num_posar, numMaxim, aux, 0);
    	 aux.x = 0;
    	 quita_nums(aux.x, num_posar, numMaxim, aux, 0);
    	 tauler = tauler_def.clone();
    }
    
    public static void quita_nums(int num_inicials, int num_posats, int numMaxim, Contador numMin, int j){
    	int dimensioTauler = tauler.length;
    	
    	BuscarSolucion(tauler.length, tauler[0].length);
    	if(nSols > 1);
    	else if(num_inicials == num_posats){
    		
    		tauler_def = tauler.clone();
    	}
    	else if (j>= tauler.length);
    	else{
    		
    		for (int i = 0; i < tauler.length; ++i){
    			int numRetorn = tauler[i][j];
    			if(numMin.x > num_posats) numMin.x = num_posats;
    			if(tauler[i][j] > 0 && tauler[i][j]!= 1 && tauler[i][j] != numMaxim){
    				tauler[i][j] = 0;
    				--num_posats;
    			}
    			escriuTaluer();
    			System.out.print(" \n \n \n \n");
    			quita_nums(num_inicials, num_posats, numMaxim, numMin, j+1);
    			tauler[i][j] = numRetorn;
    			
    		}
    	}
    	
    }
    
  
    
    public static boolean veins_accesibles(int i, int j,int taulerGenerat[][]){
    	int[] direccioVertical = new int[]{-1,-1,-1,0,0,1,1,1};
        int[] direccioHoritzontal = new int[]{-1,0,1,-1,1,-1,0,1};
    
    	for (int it = 0; it < direccioVertical.length; ++it)
			if(i + direccioVertical[it] < taulerGenerat.length && i + direccioVertical[it] >= 0 &&
			j + direccioHoritzontal[it] < taulerGenerat.length && j + direccioHoritzontal[it] >= 0){
				if(taulerGenerat[i + direccioVertical[it]][j + direccioHoritzontal[it]] == 0) return false;
			}
    	return true;
    }
    
    public static void act_veins(int i, int j, int veins[][], int taulerGenerat[][], List<Coord> conjuntGeneratPos){
    	Coord auxCoord = new Coord();
    	conjuntGeneratPos.clear();
    	int valor = 9;
    	int aux;
    	int[] direccioVertical = new int[]{-1,-1,-1,0,0,1,1,1};
        int[] direccioHoritzontal = new int[]{-1,0,1,-1,1,-1,0,1};
    	for (int it = 0; it < direccioVertical.length; ++it)
			if(i + direccioVertical[it] < veins.length && i + direccioVertical[it] >= 0 &&
			j + direccioHoritzontal[it] < veins.length && j + direccioHoritzontal[it] >= 0){
				veins[i + direccioVertical[it]][j + direccioHoritzontal[it]] = veins[i + direccioVertical[it]][j + direccioHoritzontal[it]] - 1;
				aux = veins[i + direccioVertical[it]][j + direccioHoritzontal[it]];
				if(veins[i + direccioVertical[it]][j + direccioHoritzontal[it]] < valor 
					&& taulerGenerat[i + direccioVertical[it]][j + direccioHoritzontal[it]] == 0){ //Nomes si mes petit i no ja ha estat visitat
					valor = aux;
					conjuntGeneratPos.clear();
					auxCoord.x = i + direccioVertical[it];
					auxCoord.y = j + direccioHoritzontal[it];
					conjuntGeneratPos.add(auxCoord);
				}
				else if(veins[i + direccioVertical[it]][j + direccioHoritzontal[it]] == valor
					&& taulerGenerat[i + direccioVertical[it]][j + direccioHoritzontal[it]] == 0){ //Nomes si no ja ha estat visitat
						auxCoord.x = i + direccioVertical[it];
						auxCoord.y = j + direccioHoritzontal[it];
						conjuntGeneratPos.add(auxCoord);
					
				}
			}
    }
    
    public static void init_matriu(int matriu[][], int ini){
    	for(int i = 0; i < matriu.length; ++i)
    		for(int j = 0; j < matriu[0].length; ++j)
    			matriu[i][j] = ini;
        
    }
    
    
    public static void init_veins(int [][] veins, int [][] tauler_Gen){
    	int[] direccioVertical = new int[]{-1,-1,-1,0,0,1,1,1};
        int[] direccioHoritzontal = new int[]{-1,0,1,-1,1,-1,0,1};
        
    	for(int i = 0; i < veins.length; ++i)
    		for(int j = 0; j < veins[0].length; ++j)
    			for (int it = 0; it < direccioVertical.length; ++it)
    				if(i + direccioVertical[it] < veins.length && i + direccioVertical[it] >= 0 &&
    					j + direccioHoritzontal[it] < veins.length && j + direccioHoritzontal[it] >= 0)
    					if(tauler_Gen[i + direccioVertical[it]][j + direccioHoritzontal[it]] == 0) veins[i][j] += 1;
    		
    		
    	
    }
    

    
    public static void init(int[][] dist,int[][] vis){
    	for(int it = 0; it < dist.length; ++it){
        	for(int it2 = 0; it2 < dist[0].length; ++it2){
        		dist[it][it2] = -1;
        		vis[it][it2] = 0;
        	}
        }
    	
    }
    
    
    
    //devolver mejor vector con las distancias de todos?
        
       
    	
    	
    
    
    

}
