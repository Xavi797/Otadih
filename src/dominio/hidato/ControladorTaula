package hidato;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Random;
import java.util.Scanner;

public class ControladorTaula {
	
	    private Tauler tauler;
	    private static int[] numDonats, posInicial;

	    
	    private Tauler tablero; /* tablero sobre el que buscaremos la solucion */
	    private Tauler solucion; /* tablero donde guardaremos la solucion */
	    private int nSols; /* numero de soluciones encontradas (como mucho dos) */
	    private int nRest; /* numero de casillas que me quedan por poner */
	    private boolean usado[]; /* usado[i] nos dice si el numero i + 1 esta colocado */
	    private int n; /* anchura del tablero */
	    private int m; /* altura del tablero */
	    private int maxCas; /* numero de la casilla mas grande */
	    
	    
	    public void soluciona(){
	    	solucion = tauler.clonar();
	    	soluciona_aux(posInicial[0], posInicial[1], 1, 0);
	    }
	
	    public boolean soluciona_aux(int fila, int col, int n, int seguent) {
	        // System.out.println("valor n " + n);
	         int dimensioTauler = solucion.sizeTauler();
	        
	         if (fila<0 || col<0 || fila>dimensioTauler-1 || col>dimensioTauler-1)//si es fora del tauler surt
	             return false;
	         
	         
	         
	         if (n == numDonats[numDonats.length - 1]) // si es mas grande que el utlimo sale ya lleno tablero9
	             return true;
	         
	         
	         if (solucion.getCela(fila, col) != 0 && solucion.getCela(fila, col) != n)//si ya esta agafada la posicio i no es el nou numero surt
	             return false;

	         if (solucion.getCela(fila, col) == 0 && numDonats[seguent] == n)//si no hi ha cap numero pero ya esta ficat a la taula
	             return false;
	         

	         int numRetorn = solucion.getCela(fila,col);
	         if (numRetorn == n) //si el del tauler es igual al que poso incremento numdonats
	             seguent++;

	         solucion.setCela(fila, col, n);
	         int[] direccioVertical = new int[]{-1,-1,-1,0,0,1,1,1};
	         int[] direccioHoritzontal = new int[]{-1,0,1,-1,1,-1,0,1};
	         for (int i = 0; i < direccioVertical.length; ++i)
	             if (soluciona_aux(fila + direccioHoritzontal[i], col + direccioVertical[i], n + 1, seguent))
	                 return true;

	         solucion.setCela(fila, col, numRetorn);
	         return false;
	     }
	    
	    public void crea(int costat) {
		    Scanner in = new Scanner(System.in);
	    	Tauler taulerCreat = new Tauler(costat);
	        int variable = 0;
	        int seguir = 0;
	        int escriure = 0;
	         
	        System.out.println("Primera vegada omplint, acces sequencial");
	        System.out.println("Escriu el valor de cada posicio");
	        for (int posx = 0; posx < costat; ++posx) {
	            for (int posy = 0; posy < costat; ++posy) {
	            	taulerCreat.setCela(posx, posy, in.nextInt());
	            	if(taulerCreat.getCela(posx, posy) == 1){
	            		 posInicial = new int[]{posx, posy};
	            	}
	            }
	        }
	        System.out.println("Estat actual:");
	        escriuTauler(taulerCreat);
	         
	        System.out.println("Canviar alguna cela? 1:SI / 0:NO");
	        seguir = in.nextInt();
	        while (seguir == 1) {
	         
	            System.out.println("Entrar coordenades de la posicio desitjada:");
	            int x = in.nextInt();
	            int y = in.nextInt();
	            System.out.println("La posicio es: " + x + "," + y);
	             
	            System.out.println("Entrar valor desitjat:");
	            taulerCreat.setCela(x, y, in.nextInt()); 
	            if(taulerCreat.getCela(x, y) == 1){
           		 	posInicial = new int[]{x, y};
	            }
	            
	            System.out.println("Esriure? 1:SI / 0:NO");
	            if (escriure == 1 ) {
		            escriuTauler(taulerCreat);
		            escriure = 0;
	            }
	             
	            System.out.println("Seguir? 1:SI / 0:NO");
	            seguir = in.nextInt();
	        }
	         
	        tauler = taulerCreat;
	        System.out.println("Resultat final:");
	        escriuTauler(taulerCreat);
	        }
	    
	    public void escriuTauler(Tauler taulerCreat) {     // S'ha de refer escriure per quan tinguem les classes celÂ·la i tauler
	        for (int i = 0; i < taulerCreat.sizeTauler(); ++i) {
	            for (int j = 0; j < taulerCreat.sizeTauler(); ++j) {
	                if (taulerCreat.getCela(i, j) == -1)
	                    System.out.print(" . ");
	                else
	                    System.out.printf(taulerCreat.getCela(i, j) > 0 ? "%2d " : "__ ", taulerCreat.getCela(i, j));
	            }
	            System.out.println();
	        }
	    }
	    
	    public void BuscarSolucion(int anchura, int altura) {
	        n = anchura;
	        m = altura;
	        tablero = tauler.clonar();
	        solucion = null;
	        nSols = nRest = maxCas = 0;
	        usado = new boolean[altura*anchura];

	        for (int i = 0; i < altura*anchura; ++i)
	            usado[i] = false;

	        for (int i = 0; i < n; ++i) {
	            for (int j = 0; j < m; ++j) {
	                if (tablero.getCela(i, j) > 0) usado[tablero.getCela(i, j) - 1] = true;
	                else if (tablero.getCela(i, j) == 0) ++nRest;
	                maxCas = Math.max(maxCas, tablero.getCela(i, j));
	            }
	        }

	        backtrack();
	    }
	    
	    private void backtrack() {
	        if (nRest == 0) {
	            solucion = tablero.clonar();
	            ++nSols;
	        }
	        else {
	            int minI = 0;
	            int minJ = 0;
	            int minPosats = 10;

	            for (int i = 0; i < n; ++i) {
	                for (int j = 0; j < m; ++j) {
	                    if (tablero.getCela(i, j) == 0) {
	                        int nVolt = 0;
	                        int k1 = Math.max(0, i - 1);
	                        int k2 = Math.min(n - 1, i + 1);
	                        int s1 = Math.max(0, j - 1);
	                        int s2 = Math.min(m - 1, j + 1);

	                        for (int k = k1; k <= k2; ++k)
	                            for (int s = s1; s <= s2; ++s)
	                                if (tablero.getCela(k, s) == 0)
	                                    ++nVolt;

	                        if (nVolt < minPosats) {
	                            minPosats = nVolt;
	                            minI = i;
	                            minJ = j;
	                        }
	                    }
	                }
	            }

	            --nRest;
	            for (int k = 1; (nSols < 2) && (k < maxCas - 1); ++k) {
	                if(!usado[k]) {
	                    usado[k] = true;
	                    tablero.setCela(minI, minJ, k+1);

	                    if (fastCheck(minI, minJ) && deepCheck()) backtrack();

	                    tablero.setCela(minI, minJ, 0);
	                    usado[k] = false;
	                }
	            }
	            ++nRest;
	        }
	    }
	    
	    private boolean fastCheck(int i, int j) {

	        for (int k = Math.max(0, i - 1); k <= Math.min(n - 1, i + 1); ++k) {
	            for (int s = Math.max(0, j - 1); s <= Math.min(m - 1, j + 1); ++s) {
	                if (tablero.getCela(k,s) > 0) {
	                    boolean antFound = false;
	                    boolean sigFound = false;
	                    int nBuits = 0;

	                    int t1 = Math.max(0, k - 1);
	                    int t2 = Math.min(n - 1, k + 1);
	                    int r1 = Math.max(0, s - 1);
	                    int r2 = Math.min(m - 1, s + 1);

	                    for (int t = t1; t <= t2; ++t) {
	                        for (int r = r1; r <= r2; ++r) {
	                            if (tablero.getCela(t,r) == 0) ++nBuits;
	                            else if (tablero.getCela(t,r) == tablero.getCela(k,s) - 1)
	                                antFound = true;
	                            else if (tablero.getCela(t,r) == tablero.getCela(k,s) + 1)
	                                sigFound = true;
	                        }
	                    }

	                    if (nBuits == 1 && tablero.getCela(k,s) > 1 && tablero.getCela(k,s) < maxCas &&
	                      !antFound && !sigFound) return false;
	                    else if (nBuits == 0) {
	                        if (tablero.getCela(k,s) == 1) {
	                            if (!sigFound) return false;
	                        }
	                        else if (tablero.getCela(k,s) == maxCas) {
	                            if (!antFound) return false;
	                        }
	                        else if (!sigFound || !antFound) return false;
	                    }
	                    if (!antFound && tablero.getCela(k,s) > 1 && usado[tablero.getCela(k,s) - 2])
	                        return false;
	                    if (!sigFound && tablero.getCela(k,s) < maxCas && usado[tablero.getCela(k,s)])
	                        return false;
	                }
	            }
	        }
	        return true;
	    }
	    
	    private boolean deepCheck() {
	        int dist[][] = new int[n][m];

	        int ant = 0;
	        for (int k = 1; k < maxCas; ++k) {
	            if (usado[k]) {
	                Queue<Integer> cola = new LinkedList<Integer>();
	                int pos = 0;
	                for (int i = 0; i < n; ++i) {
	                    for (int j = 0; j < m; ++j) {
	                        if (tablero.getCela(i,j) == ant + 1) {
	                            pos = i*m + j;
	                            dist[i][j] = 0;
	                        }
	                        else dist[i][j] = n + m;
	                    }
	                }
	                cola.add(pos);
	                boolean ok = true;
	                while (ok && !cola.isEmpty()) {
	                    int val = cola.poll().intValue();
	                    int x = val/m;
	                    int y = val%m;
	                    int nuevaDist = 1 + dist[x][y];
	       
	                    for (int s = Math.max(0, x - 1); ok && s <= Math.min(n - 1, x + 1); ++s) {
	                        for (int t = Math.max(0, y - 1); ok && t <= Math.min(m - 1, y + 1); ++t) {
	                            if (tablero.getCela(s,t) == k + 1) {
	                                if (nuevaDist > k - ant) return false;
	                                ok = false;
	                            }
	                            else if ((tablero.getCela(s,t) == 0) && (nuevaDist < dist[s][t])) {
	                                dist[s][t] = nuevaDist;
	                                cola.add(s*m + t);
	                            }
	                        }
	                    }
	                }
	                if (ok) return false;
	                ant = k;
	            }
	        }
	        return true;
	    }
	    
	    public void generaTauler(int costat, int numInicials, int forats) {
	    	 int numMaxim = costat*costat - forats;
	    	 Coord posInicialProvisional = new Coord();
	         Coord coordenadaAux = new Coord();
	         List<Coord> conjuntGeneratPos = new ArrayList<>();
	         List<Integer> conjuntGenerat = new ArrayList<>();
	         Tauler taulerGenerat = new Tauler(costat);
	         Tauler taulerGeneratAux = new Tauler(costat);
	        
	         Random rand = new Random();
	         int veins[][] = new int [costat][costat];
	         int num_posar = 0;

	         //FER FORATS
	         boolean tauler_correcte = false;
	         while(!tauler_correcte){
		         //do while....
	        	 taulerGeneratAux = taulerGenerat.clonar();
	        	 conjuntGenerat.clear();
		         init_matriu(veins, 0);
		         init_veins(veins,taulerGeneratAux); // inicialitza numero de veis de cada numero
		         int posx, posy;
			     do{
			         posx = rand.nextInt(costat);
			         posy = rand.nextInt(costat);
			         coordenadaAux.x = posx;
			         coordenadaAux.y = posy;
			     }while(taulerGeneratAux.getCela(posx, posy) != 0 && !conjuntGeneratPos.contains(coordenadaAux));
			     
		         conjuntGeneratPos.add(coordenadaAux);
		         posInicialProvisional.x = posx; //posicio del 1
		         posInicialProvisional.y = posy;
		         
		         num_posar = 1;
		         boolean pathing = true;
		         
		         while(pathing){
		        	 taulerGeneratAux.setCela(coordenadaAux.x, coordenadaAux.y, num_posar);
		        	 conjuntGenerat.add(num_posar);
		        	 if(veins_accesibles(coordenadaAux.x,coordenadaAux.y,taulerGeneratAux) || num_posar == numMaxim) pathing = false;
		        	 else{
		        		 conjuntGeneratPos.clear();
		        		 act_veins(coordenadaAux.x,coordenadaAux.y,veins,taulerGeneratAux,conjuntGeneratPos);
		        		 int aux_Random = rand.nextInt(conjuntGeneratPos.size());
		        		 coordenadaAux = conjuntGeneratPos.get(aux_Random);
		        		 ++num_posar;
		        	 }
		        
		         }
		         if(num_posar == numMaxim) tauler_correcte = true; //Tauler correcte, pasem a treure numeros.
		         
	         }//fi while
	         posInicial = new int[]{posInicialProvisional.x, posInicialProvisional.y};
	         //TREURE NUMEROS fins NUMINICIALS SI ES POT O FINS QUE TROBEN MES DE 1 SOLUCIO*/
	         
	         quita_nums2(numInicials, num_posar, numMaxim,taulerGeneratAux);
	         
	         Collections.sort(conjuntGenerat);
	         numDonats = new int[conjuntGenerat.size()];
	         for (int i = 0; i < numDonats.length; i++)
	             numDonats[i] = conjuntGenerat.get(i);
	         tauler = taulerGeneratAux;
	         
	         //int numMin = numMaxim;
	         //treu_nums(posInicialProvisional.x,posInicialProvisional.y,numInicials,num_posar,numMaxim,numMin,1);

	         
	    }
	    
	    
	    private void quita_nums2(int num_inicials, int num_posats, int numMaxim, Tauler taulerGenerat){
	    	int tam = taulerGenerat.sizeTauler();
	    	Random rand = new Random();
	    	Coord auxCoord = new Coord();
	    	int intents = 0;
	    	List<Coord> conjuntGeneratPos = new ArrayList<>();
	    	while(num_inicials < num_posats && intents < 10){
	    		int posx, posy;
	    		do{
	    			posx = rand.nextInt(tam);
	            	posy = rand.nextInt(tam);
	    			auxCoord.x = posx;
	    			auxCoord.y = posy;
	    			
	    			++intents;
	    		}while((taulerGenerat.getCela(posx, posy) == 1 || taulerGenerat.getCela(posx, posy) == numMaxim || taulerGenerat.getCela(posx, posy)== -1 
	    				|| conjuntGeneratPos.contains(auxCoord)) && (intents < 5 && num_inicials < num_posats));
	    		
	    		int numRetorn = taulerGenerat.getCela(posx, posy);
	    		taulerGenerat.setCela(posx, posy, 0);
	    		
	    		tauler = taulerGenerat;
	    		BuscarSolucion(tam, tam);
	    		if(nSols > 1){
	    			taulerGenerat.setCela(posx, posy, numRetorn);
	    			++intents;
	    			conjuntGeneratPos.add(auxCoord);
	    		}
	    		else {
	    			num_posats--;
	    			intents = 0;
	    			System.out.println("aqiiiiiiiiiiiii");
	    		}
	    		System.out.println("or here bro");
	    	}
	    	
	    }
	    
	    public static boolean veins_accesibles(int i, int j,Tauler taulerGenerat){
	    	int tamany = taulerGenerat.sizeTauler();
	    	int[] direccioVertical = new int[]{-1,-1,-1,0,0,1,1,1};
	        int[] direccioHoritzontal = new int[]{-1,0,1,-1,1,-1,0,1};
	    
	    	for (int it = 0; it < direccioVertical.length; ++it)
				if(i + direccioVertical[it] < tamany && i + direccioVertical[it] >= 0 &&
				j + direccioHoritzontal[it] < tamany && j + direccioHoritzontal[it] >= 0){
					if(taulerGenerat.getCela(i + direccioVertical[it], j + direccioHoritzontal[it]) == 0) return false;
				}
	    	return true;
	    }
	    
	    private void act_veins(int i, int j, int veins[][], Tauler taulerGenerat, List<Coord> conjuntGeneratPos){
	    	Coord auxCoord = new Coord();
	    	conjuntGeneratPos.clear();
	    	int valor = 9;
	    	int aux;
	    	int[] direccioVertical = new int[]{-1,-1,-1,0,0,1,1,1};
	        int[] direccioHoritzontal = new int[]{-1,0,1,-1,1,-1,0,1};
	    	for (int it = 0; it < direccioVertical.length; ++it)
				if(i + direccioVertical[it] < veins.length && i + direccioVertical[it] >= 0 &&
				j + direccioHoritzontal[it] < veins.length && j + direccioHoritzontal[it] >= 0){
					veins[i + direccioVertical[it]][j + direccioHoritzontal[it]] = veins[i + direccioVertical[it]][j + direccioHoritzontal[it]] - 1;
					aux = veins[i + direccioVertical[it]][j + direccioHoritzontal[it]];
					if(veins[i + direccioVertical[it]][j + direccioHoritzontal[it]] < valor 
						&& taulerGenerat.getCela(i + direccioVertical[it], j + direccioHoritzontal[it]) == 0){ //Nomes si mes petit i no ja ha estat visitat
						valor = aux;
						conjuntGeneratPos.clear();
						auxCoord.x = i + direccioVertical[it];
						auxCoord.y = j + direccioHoritzontal[it];
						conjuntGeneratPos.add(auxCoord);
					}
					else if(veins[i + direccioVertical[it]][j + direccioHoritzontal[it]] == valor
						&& taulerGenerat.getCela(i + direccioVertical[it], j + direccioHoritzontal[it]) == 0){ //Nomes si no ja ha estat visitat
							auxCoord.x = i + direccioVertical[it];
							auxCoord.y = j + direccioHoritzontal[it];
							conjuntGeneratPos.add(auxCoord);
						
					}
				}
	    }
	    
	    private void init_matriu(int matriu[][], int ini){
	    	for(int i = 0; i < matriu.length; ++i)
	    		for(int j = 0; j < matriu[0].length; ++j)
	    			matriu[i][j] = ini;
	        
	    }
	    
	    
	    private void init_veins(int [][] veins, Tauler tauler_Gen){
	    	int[] direccioVertical = new int[]{-1,-1,-1,0,0,1,1,1};
	        int[] direccioHoritzontal = new int[]{-1,0,1,-1,1,-1,0,1};
	        
	    	for(int i = 0; i < veins.length; ++i)
	    		for(int j = 0; j < veins[0].length; ++j)
	    			for (int it = 0; it < direccioVertical.length; ++it)
	    				if(i + direccioVertical[it] < veins.length && i + direccioVertical[it] >= 0 &&
	    					j + direccioHoritzontal[it] < veins.length && j + direccioHoritzontal[it] >= 0)
	    					if(tauler_Gen.getCela(i + direccioVertical[it], j + direccioHoritzontal[it]) == 0) veins[i][j] += 1;
	    		
	    		
	    	
	    }
	    
	    public Tauler getSolucio(){
			return solucion;
	    }
	    public Tauler getTauler(){
			return tauler;
	    }
	    
	    
}
